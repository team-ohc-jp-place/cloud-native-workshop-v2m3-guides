= サービスメッシュとアイデンティティ
:experimental:

このモジュールでは、分散環境でのカスケード障害を防ぐ方法、サービスの誤動作を検出する方法、ビジネスロジック内にに回復力と監視を埋め込むことを回避する方法を学びます。分散ネットワーク上にマイクロサービスを配置した分散アーキテクチャへとアプリケーションを移行する際には、多くの新しい課題が待ち受けています。

コンテナやOpenShiftのようなコンテナオーケストレーションプラットフォームのような技術は、分散アプリケーションのデプロイメントを非常にうまく解決してくれますが、分散アプリケーションにはいくつかの課題が残っています:

* 予測不可能な故障モード
* エンドツーエンドのアプリケーションの正確性の検証
* 予期せぬシステムの劣化
* 連続的なトポロジーの変化
* 伸縮性のある/揮発性の/過渡的な資源の使用

今日では、開発者はこれらの課題を考慮して、次のようなことをする責任があります:

* サーキットブレーキングとバルクヘディング (例: Netfix Hystrix)
* タイムアウト/リトライ
* サービスディスカバリー（例：Eureka)
* クライアント側のロードバランシング (Netfix Ribbon)

もう一つの課題は、ランタイムや言語ごとに異なるライブラリやフレームワークを使用してこれらの問題に対処することで、選択した言語やランタイムに特定のライブラリの実装がない場合もあります。

このセクションでは、OpenShiftの _Service Mesh_ の使い方を探っていきます。Service Meshはオープンソースプロジェクトの _Istio_ をベースにしています。これにより、ダイナミックな分散アプリケーションの新しい世界に直面した際に、はるかに堅牢で信頼性が高く、回復力のあるアプリケーションを実現します。

=== Istioとは何か?

image::istio-logo.png[Logo, 600, align="center"]

http://istio.io[Istio^] はOpenShift Service Meshの基盤を形成し、マイクロサービスとアプリケーション間の通信を透過的に管理するために設計されたオープンでプラットフォームに依存しないサービスメッシュです。これにより、サービスメッシュ全体のモニタリングと運用制御が可能になります。サービスのネットワーク全体で統一された多数の主要機能を提供します。

* *トラフィック管理* - サービス間のトラフィックとAPIコールの流れを制御し、コールの信頼性を高め、悪条件に直面してもネットワークをより強固なものにします。
* *Observability(可観測性)* - サービス間の依存関係、サービス間のトラフィックの性質と流れを理解し、問題を迅速に特定する能力を提供します。
* *ポリシー適用* - サービス間の相互作用に組織ポリシーを適用し、アクセスポリシーが適用¥され、コンシューマー間でリソースが公平に分配されるようにします。ポリシーの変更は、アプリケーション・コードを変更するのではなく、メッシュを設定することで行われます。
* *サービスのアイデンティティとセキュリティ* - メッシュ内のサービスに検証可能なアイデンティティを提供し、信頼性の度合いが異なるネットワーク上を流れるサービストラフィックを保護する機能を提供します。

これらの機能により、アプリケーションコード、基盤となるプラットフォーム、およびポリシー間の結合が大幅に減少します。この結合が減少することで、サービスの実装が容易になるだけでなく、オペレータが環境間でアプリケーションを移動したり、新しいポリシースキームに移行したりするのがより簡単になります。その結果、アプリケーションは本質的に移植性が高くなります。

楽しそうでしょ? さっそく始めましょう!

=== ラボの準備

すでに今日のラボに取り組んでいる方は、CodeReady Workspaces環境に慣れていると思いますので、下の *Import Project* セクションまでスキップしてください。

https://www.eclipse.org/che/[Eclipe Che^] をベースにしたオンラインIDEであるRed Hat CodeReady Workspacesを使用します。 *ファイルへの変更は数秒ごとに自動保存されます* ので、明示的に変更を保存する必要はありません。

開始するには、 {{ ECLIPSE_CHE_URL }}[CodeReady Workspacesインスタンスにアクセス^] し、割り当てられたユーザー名とパスワード(例: `{{ USER_ID }}/{{ CHE_USER_PASSWORD }}` )を使用してログインします。

image::che-login.png[cdw, 700]

ログインすると、個人のダッシュボードが表示されます。以下のように、左側にあるあらかじめ作成されたワークスペースの名前をクリックします（割り当てられた番号によって名前が異なります）。また、中央のワークスペースの名前をクリックし、画面右上の _Open_ と書かれた緑色の {{ USER_ID}}-名前空間 をクリックします。

image::che-landing.png[cdw, 700]

1～2分後にはワークスペースが開きます:

image::che-workspace.png[cdw, 600, align="center"]

このIDEはEclipse Cheをベースにしています(すなわちMicrosoft VS Code editorをベースにしているということでもあります)。

左側には、プロジェクトエクスプローラ、検索、バージョン管理（Gitなど）、デバッグ、その他のプラグインの間をナビゲートするためのアイコンがあります。 あなたはこのワークショップの間にこれらを使用します。自由にクリックして何ができるか見てみてください:

image::crw-icons.png[cdw, 400, align="center"]

[NOTE]
====
動作がおかしくなったりした場合には、ブラウザタブをリロードして表示を更新してみてください。
====

CodeReady Workspaces の多くの機能は *Commands* からアクセスできます。いくつかのコマンドは、ホームページにリンク付きで表示されています（例：_New File..._, _Git Clone..._, など）。

メニューにないコマンドを実行したい場合は、 kbd:[F1] を押してコマンドウィンドウを開くか、 kbd:[Control+SHIFT+P] (Mac OS X では kbd:[Command+SHIFT+P] ) を押してコマンドを実行することができます。

==== プロジェクトのインポート

最初のプロジェクトをインポートしてみましょう。 **Git Clone...** をクリックします (または kbd:[F1] と入力して 'git' と入力し、自動補完された _Git Clone..._ をクリックします)。

image::che-workspace-gitclone.png[cdw, 600, align="center"]

プロンプトの指示に従って、 **リポジトリURL** に次の値を使用してください。 *FireFox* を使用している場合、最後に余分なスペースを貼り付けてしまう可能性があるので、貼り付けた後はバックスペースを押してください:

[source, shell, role="copypaste"]
----

https://github.com/RedHat-Middleware-Workshops/cloud-native-workshop-v2m3-labs.git

----

image::crw-clone-repo.png[crw, 600, align="center"]

プロジェクトはワークスペースにインポートされ、左上の *エクスプローラ* ペインをクリックすると、プロジェクト エクスプローラに表示されます:

image::crw-clone-explorer.png[crw, 600, align="center"]

==== 重要: 適切な Git ブランチをチェックアウトしてください

プロジェクトファイルの正しいバージョンを使用していることを確実にするために、CodeReadyターミナルでこのコマンドを実行してください:

[source,sh,role="copypaste"]
----
cd $CHE_PROJECTS_ROOT/cloud-native-workshop-v2m3-labs && git checkout ocp-4.5
----

=== 他のプロジェクトの削除

もし今日、他のモジュール(例えば `cloud-native-workshop-v2m1-lab`)を完了している場合は、エクスプローラでプロジェクト名を右クリックして *Delete* を選択し、警告を受け入れてワークスペースからそれらを削除してください。このラボのためにインポートした新しいプロジェクトを削除しないように注意してください。

image::remove-workspace.png[remove, 700]

[NOTE]
====
CodeReady ワークスペースのターミナルウィンドウについて。Developer ワークスペースで実行しているコンテナのいずれかのターミナルウィンドウを開くことができます。これらのラボの残りの部分については、ターミナルでコマンドを実行する必要がある場合はいつでも、右側の **>_New Terminal** コマンドを使用できます:
====

image::codeready-workspace-terminal.png[codeready-workspace-terminal, 600, align="center"]
