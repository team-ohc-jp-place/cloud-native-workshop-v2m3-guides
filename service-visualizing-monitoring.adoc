= Lab 2 - サービスの可視化と監視
:experimental:

このラボでは、*Kiali*, *Prometheus*, *Grafana* を使ってサービスメッシュを可視化し、*VirtualService* や *A/B Testing* などの基本的な *Istioの機能* を設定する方法を学びます。

=== 1. アプリケーション負荷の生成

メトリクスの力をよりよく理解するために、アプリケーションに継続的にアクセスし、約 30 分間負荷を生成するエンドレスループを設定してみましょう。この目的のためだけに別のターミナルを開きます。

新しい _CodeReady Workspaces Terminal_ を開き、以下のコマンドを実行します:

[source, shell, role="copypaste"]
----
BOOK_URL=istio-ingressgateway-{{ USER_ID }}-istio-system.{{ ROUTE_SUBDOMAIN}}

for i in {1..1000} ; do curl -o /dev/null -s -w "%{http_code}\n" http://$BOOK_URL/productpage ; sleep 2 ; done
----

このコマンドは、アプリケーションにエンドレスでアクセスし、別のターミナルウィンドウでHTTPステータスの結果を報告します。スクリプトはエンドレスで `200` を返すはずです。

このアプリケーションの負荷が実行されている状態で、メトリクスは次のいくつかのステップではるかに興味深いものになります。

=== 2. Kiali を試す

*Kiali*は、単一のUIからサービスメッシュを管理・監視することができます。このUIでは、設定の表示、トラフィックの流れと健全性の監視、トレースの分析を行うことができます。

https://kiali-{{ USER_ID }}-istio-system.{{ ROUTE_SUBDOMAIN }}[Kiali console^] を開きます。

_OpenShift Login_ の画面が表示されるはずです。以下のようにユーザー名とパスワードを入力し、_Log In_ をクリックします。

* Username: `{{ USER_ID }}`
* Password: `{{ OPENSHIFT_USER_PASSWORD }}`

Kialiでは、このように _Overvew_ のページが表示されます:

image::kiali-all-namespaces.png[kiali, 700]

==== サービスグラフ

左側の _Graph_ ページをクリックして、*Display* の *Traffic Animation* にチェックを入れます。また、上部の _Namespace_ ドロップダウンで `{{ USER_ID }}-bookinfo` プロジェクトを選択する必要があります:

image::kiali-service-graph.png[kiali, 700]

これは、すべてのマイクロサービスが、それらを通過するリクエストによって接続されたグラフを示しています。このページでは、サービスがどのように相互作用しているかを見ることができます。 _productpage_ から _reviews_ へのトラフィックが、3 つのバージョンの reviews サービスすべてに均等にヒットしていること、そして _v2_ と _v3_ が順番に _ratings_ サービスにヒットしていることに注目してください (一方で _v1_ はヒットしていないので、_v1_ に負荷分散しても _stars_ は実行されません)。

==== アプリケーション

左側のナビゲーションの *Applications* メニューをクリックしてください。このページでは、クラスタ内で実行されているすべてのサービスの一覧と、ヘルスステータスなどの追加情報を表示することができます。

image::kiali-applications.png[kiali, 700]

*productpage* のアプリケーションをクリックすると、その詳細を見ることができます。また、サービスがオンラインになっていて、リクエストにエラーなく対応している場合は、*Health* の項目でサービスのヘルスステータスを確認することができます。

image::kiali-app-productpage.png[kiali, 700]

*Inbound Metrics* をクリックすると、以下のようにアプリケーションのメトリクスを見ることができます:

image::kiali-app-productpage-inbound.png[kiali, 700]

*Outbound Metrics* をクリックすると、以下のようにアプリケーションのメトリクスを見ることができます:

image::kiali-app-productpage-outbound.png[kiali, 700]

==== ワークロード

左側のナビゲーションの *Workloads* メニューをクリックします。このページでは、アプリケーションに存在するすべてのワークロードのリストを見ることができます。

image::kiali-app-productpage-workload.png[kiali, 700]

*product-page-v1* ワークロードをクリックしてください。ここでは、ワークロードに含まれるポッドやサービスなど、ワークロードの詳細を見ることができます:

image::kiali-app-productpage-workload-v1.png[kiali, 700]

_Inbound Metrics_ をクリックすると、ワークロードのメトリクスを確認することができます。メトリクスは _Application_ のものと同じです。

==== サービス

左のナビゲーションの *Services* メニューをクリックしてください。ここでは、すべてのサービスの一覧を見ることができます。

image::kiali-services.png[kiali, 700]

*productpage* サービスをクリックすると、メトリクス、トレース、ワークロード、仮想サービス、デスティネーションルールなどのサービスの詳細が表示されます:

image::kiali-services-productpage.png[kiali, 700]

==== 分散トレース

Kiali は https://www.jaegertracing.io/[Jaeger^] との統合機能も備えています。 これにより、アプリケーションを構成する様々なマイクロサービスを介してリクエストのパスをたどることができます（アプリ自体を更新する必要はありません！）。

生成されたトレースを表示するには、左側の **Distributed Tracing** リンクをクリックします:

image::kiali-tracing.png[kiali, 700]

これで https://jaeger-{{ USER_ID }}-istio-system.{{ ROUTE_SUBDOMAIN }}[Jaeger Query console^] が開きます。

_OpenShift Login_ の画面が表示されるはずです。以下のようにユーザー名とパスワードを入力し、 _Log In_ をクリックします:

* Username: `{{ USER_ID }}`
* Password: `{{ OPENSHIFT_USER_PASSWORD }}`

イェーガーのクエリページが表示されます:

image::kiali-tracing-jaeger.png[kiali, 700]

* **Service**: `productpage.{{USER_ID}}-bookinfo`
* **Operation**: `all`

次に **Find Traces** をクリックします。これで最近のトレースが表示されます:

image::kiali-tracing-traces.png[kiali, 700]

上図のように、そのうちの1つをクリックすると、詳細なトレースとスパンのデータが得られます:

image::kiali-tracing-traces-trace.png[kiali, 700]

このトレースはいくつかの入れ子になったスパンで構成されており、それぞれがBookinfoサービスコールに対応しており、すべて `/productpage リクエストに応答して実行されています。

全体の処理時間は23.23msで、detailsサービスが2.04ms、reviewsサービスが7.17ms、ratingサービスが0.72msでした。リモートサービスへの各コールは、クライアント側とサーバー側のスパンで表されます。

この情報を使用して（さらに2つの異なるトレースを比較して）、アプリケーションの問題を迅速に発見することができます。

=== 3. Prometheus によるメトリクスのクエリー

https://prometheus.io/[Prometheus] は定期的にアプリケーションを _scrape_ してメトリクスを取得します (デフォルトではアプリケーションの `/metrics` エンドポイント)。Istio 用の Prometheus アドオンは、Istio Mixer エンドポイントを _scrape_ して、公開されたメトリクスを収集するようにあらかじめ設定された Prometheus サーバです。Prometheus は、それらのメトリクスの永続的な保存とクエリのメカニズムを提供します。

https://prometheus-{{USER_ID }}-istio-system.{{ ROUTE_SUBDOMAIN }}[Prometheus console^] を開き、 *Log in with OpenShift* をクリックします。

_OpenShift Login_ の画面が表示されるはずです。以下のようにユーザー名とパスワードを入力し、 _Log In_ をクリックします。Prometheusへのアクセスを許可するために _Requested permissions_ を持っている場合は、 *Allow selected permissions* をクリックしてください。すると、このようなプロメテウスのホーム画面が表示されます:

image::istio-prometheus-landing.png[istio-prometheus, 700]

ウェブページの上部にある `Expression` の入力ボックスに、以下のテキストを入力します。そして、 *Execute* ボタンをクリックしてください。

[source,sh,role="copypaste"]
----
istio_request_duration_seconds_count
----

アプリケーションの各サービスが何回アクセスされたかのカウントとともに一覧表示されていることを確認してください。

image::istio-prometheus-console.png[Prometheus console, 700]

また、 _Graph_ タブをクリックすることで、結果を時間経過とともにグラフ化することもできます（例えば、時間枠を1時間から1分に調整）。

image::istio-prometheus-graph.png[Prometheus graph, 700]

他の expression も試してみましょう:

* _productpage_ サービスへの全リクエスト数の合計:

[source,sh,role="copypaste"]
----
istio_request_duration_seconds_count{destination_service=~"productpage.*"}
----

* _reviews_ サービスの _v3_ への全リクエスト数の合計:

[source,sh,role="copypaste"]
----
istio_request_duration_seconds_count{destination_service=~"reviews.*", destination_version="v3"}
----

* Rate of requests over the past 5 minutes to all _productpage_ services:
* 全ての _productpage_ サービスへの過去5分間のリクエストレート:

[source,sh,role="copypaste"]
----
rate(istio_request_duration_seconds_count{destination_service=~"productpage.*", response_code="200"}[5m])
----

必要なデータを抽出するために実行できるクエリは、非常に多くの異なるものがあります。詳細は https://prometheus.io/docs[Prometheusドキュメント] を参照してください。

=== 4. Grafanaによるメトリクスの可視化

アプリケーションでサービスやインタラクションの数が増えてくると、このスタイルのメトリクスには少し圧倒されるかもしれません。
https://grafana.com/[Grafana^] は、Istio データプレーンから抽出された多くの利用可能な Prometheus メトリクスを視覚的に表現し、問題を迅速に発見して対策を講じるために使用できます。

https://grafana-{{ USER_ID }}-istio-system.{{ ROUTE_SUBDOMAIN }}[Grafana console^] を開きます。

_OpenShift Login_ の画面が表示されるはずです。以下のようにユーザー名とパスワードを入力し、 _Log In_ をクリックします。Prometheusへのアクセスを許可するために _Requested permissions_ を持っている場合は、 *Allow selected permissions* をクリックしてください。すると、このような Prometheus のホーム画面が表示されます:

image::grafana-home.png[Grafana graph, 700]

==== Istio Mesh メトリクス

*Dashboard Icon > Manage > Istio > Istio Mesh Dashboard* を選択して、Istio meshメトリクスを表示します:

image::grafana-mesh-metrics-select.png[Grafana graph, 700]

ビルトインの Istio メトリクス・ダッシュボードが表示されます:

image::grafana-mesh-metrics.png[Grafana graph, 700]

==== Istio Service メトリクス

それでは、 *productpage* サービスの詳細なメトリクスを見てみましょう。 *productpage.{{ USER_ID }}-bookinfo.svc.cluster.local* をクリックすると、サービスダッシュボードは以下のようになります:

image::grafana-service-metrics.png[Grafana graph, 700]

Istio用のGrafana Dashboardは、3つの主要なセクションで構成されています:

* _Global Summary View_ は、サービスメッシュを流れる HTTP リクエストのハイレベルなサマリーを提供します。
* _Mesh Summary View_ は、グローバルサマリービューよりも若干詳細な情報を提供し、サービスごとのフィルタリングと選択を可能にします。
* _Individual Services View_ は、メッシュ内の各個別サービス (HTTP と TCP) のリクエストとレスポンスに関するメトリクスを提供します。

[NOTE]
====
Bookinfoはhttpベースのサービスのみを使用しているため、 _TCP Bandwidth_ のメトリクスは空欄になっています。ダッシュボードの下の方には、このサービスを呼び出すワークロード(``Client Workloads'' と表示されている)と、このサービスからのリクエストを処理するワークロード( _Service Workloads_ と表示されている)のメトリクスが表示されています。
====

ダッシュボードの上部にあるドロップダウン・リストを使用して、別のサービスに切り替えたり、 _client-_ および _service-workloads_ でメトリクスをフィルタリングしたりできます。

==== Istio Workload メトリクス

ワークロードダッシュボードに切り替えるには、画面左上隅のドロップダウンリストから *Dashboard Icon > Manage > Istio > Istio Workload Dashboard* を選択します。このような画面が表示されるはずです:

image::grafana-workload-metrics.png[Grafana graph, 700]

このダッシュボードには、ワークロードのメトリクスと、クライアント(インバウンド)とサービス(アウトバウンド)のワークロードのメトリクスが表示されます。ダッシュボードの上部にあるドロップダウンリストを使って、別のワークロードに切り替えたり、インバウンドまたはアウトバウンドのワークロードでメトリクスをフィルタリングしたりすることができます。

ダッシュボードの作成、設定、編集方法については、http://docs.grafana.org/[Grafana documentation^] を参照してください。

開発者としては、アプリケーション自体に何もしなくても、これらのメトリクスからかなりの情報を得ることができます。次のセクションでは、新しいツールを使って、アプリケーションの問題を診断して修正し、アプリケーションをより回復力のある堅牢なものにするための Istio の真の力を見てみましょう。

=== 5. リクエストルーティング

このタスクでは、ウェイトと HTTP ヘッダーに基づいて動的なリクエストルーティングを設定する方法を示します。

_Route rules_ control how requests are routed within an Istio service mesh. Route rules provide:
_Route rules_ は、Istio サービスメッシュ内でリクエストがどのようにルーティングされるかを制御します。 Route ruleは以下を提供します:

* **Timeouts** 遅いサービスの待ち時間を最小限に抑える
* **Bounded retries** タイムアウトバジェットとリトライ間のジッターを可変にする
* **Limits** アップストリームサービスへの同時接続数とリクエスト数を制限する
* **Active (periodic) health checks** ロードバランシングプールの各メンバーのアクティブな（定期的な）ヘルスチェックを行う
* **Fine-grained circuit breakers** 細粒度のサーキットブレーカー（パッシブヘルスチェック） - ロードバランシングプールのインスタンスごとに適用される

リクエストは、送信元と送信先、HTTP ヘッダーフィールド、個々のサービスのバージョンに関連付けられた重みに基づいてルーティングすることができます。たとえば、route rule はリクエストをサービスの異なるバージョンにルーティングすることができます。

これらの機能を組み合わせることで、サービスメッシュは故障したノードを許容し、局所的な故障が他のノードに不安定性を連鎖させることを防ぐことができます。しかし、アプリケーションは、適切なフォールバック・アクションを取ることで障害に対処するように設計されていなければなりません。たとえば、ロードバランシングプール内のすべてのインスタンスが故障した場合、Istio は HTTP 503 を返します。アップストリームサービスからのHTTP 503エラーコードを処理するために必要なフォールバックロジックを実装するのはアプリケーションの責任です。

アプリケーションがすでに何らかの防御手段を提供している場合(https://github.com/Netflix/Hystrix[Netflix Hystrix^] を使用するなど)は、それでOKです。 *Istio* はアプリケーションからは完全に透過的です。Istioによって返された失敗応答は、呼び出しが行われた上流のサービスによって返された失敗応答と区別できません。

=== 6. サービスバージョン

Istioはサービスバージョンというコンセプトを導入しました。これは、サービスインスタンスをバージョン (_v1_, _v2_) や環境 (_staging_, _prod_) によって細分化するためのより細かい方法です。これらのバリエーションは必ずしも異なる API のバージョンである必要はありません: 同じサービスを異なる環境 (prod, staging, dev など) にデプロイして反復的に変更することができます。これが使用される一般的なシナリオとしては、A/B テストやカナリーロールアウトなどがあります。Istioの https://istio.io/docs/concepts/traffic-management/rules-configuration.html[traffic routing rules^] は、サービス間のトラフィックを追加で制御するためのサービスバージョンを参照することができます。

image::versions.png[Versions, 500]

上の図に示すように、サービスのクライアントは、サービスの異なるバージョンを知ることはありません。クライアントは、サービスのホスト名/IPアドレスを使用してサービスにアクセスし続けることができます。Envoyサイドカー/プロキシは、クライアントとサービス間のすべてのリクエスト/レスポンスをインターセプトして転送します。

=== 7. VirtualServiceオブジェクト

_BuildConfig_ 、_DeploymentConfig_ 、_Service_ 、_Route_ などの通常のOpenShiftオブジェクトタイプに加えて、 _VirtualService_ などの新しいオブジェクトタイプもIstioの一部としてインストールされています。これらのオブジェクトを実行中のOpenShiftクラスタに追加することで、Istioのルーティングルールを構成することができます。

私たちのアプリケーションでは、明示的なデフォルトのルート設定がなく、Istioはラウンドロビン方式でサービスのすべての利用可能なバージョンにリクエストをルーティングし、 _v1_ バージョンにヒットした場合はいつでも星はつきません。

すべてのトラフィックを _reviews:v1_ サービスバージョンに誘導する *virtual services* のデフォルトセットを作成してみましょう。

新しいターミナルを開き(他のエンドレスな `for` ループが実行されている間)、このコマンドを実行してすべてのトラフィックを `v1` にルーティングします:

[source, shell, role="copypaste"]
----
oc create -n {{ USER_ID}}-bookinfo -f $CHE_PROJECTS_ROOT/cloud-native-workshop-v2m3-labs/istio/virtual-service-all-v1.yaml
----

このデフォルトの _virtual services_ のセットは、以下で見ることができます:

[source, shell, role="copypaste"]
----
oc get virtualservices -n {{ USER_ID}}-bookinfo -o yaml
----

There are default _virtual services_ for each service, such as the one that forces all traffic to the _v1_ version of the _reviews_ service:
各サービスにはデフォルトの _virtual services_ があり、例えば、すべてのトラフィックを _reviews_ サービスの _v1_ バージョンに強制するものなどがあります:

[source, shell, role="copypaste"]
----
oc get virtualservices/reviews -n {{ USER_ID}}-bookinfo -o yaml
----

[source, yaml]
----
apiVersion: networking.istio.io/v1alpha3
kind: VirtualService
metadata:
  creationTimestamp: "2019-07-02T15:50:36Z"
  generation: 1
  name: reviews
  namespace: {{ USER_ID }}-bookinfo
  resourceVersion: "2899673"
spec:
  hosts:
  - reviews
  http:
  - route:
    - destination:
        host: reviews
        subset: v1
----

Now, access the application again in your web browser using the below link and reload the page several times - you should not see any rating stars since *reviews:v1* does not access the _ratings_ service.
さて、以下のリンクを使用してWebブラウザでアプリケーションに再度アクセスし、ページを数回リロードしてください - *reviews:v1* が _ratings_ サービスにアクセスしていないので、評価の星は表示されないはずです。

[NOTE]
====
新しいルーティングが有効になるまで1～2分かかる場合があります。それでも赤や黒の星が表示される場合は、1分ほど待ってからもう一度試してみてください。
やがて赤や黒の星が表示されなくなるはずです。
====

これを確認するには、 http://istio-ingressgateway-{{ USER_ID }}-istio-system.{{ ROUTE_SUBDOMAIN}}/productpage[Bookinfo Product Page^] にアクセスして、評価の星がないことを確認してください:

image::ratings-stopped-bookinfo.png[Versions, 700]

https://grafana-{{USER_ID }}-istio-system.{{ ROUTE_SUBDOMAIN }}[Grafana console^] に戻り、 *Istio Service Dashboard* を選択し、 _Service_ ドロップダウンで `ratings.{{USER_ID}}}-bookinfo.svc.cluster.local` サービスを選択します:

image::ratings-select-dash.png[Versions, 700]

reviewsサービスからのリクエストが停止していることに注意してください:

image::ratings-stopped.png[Versions, 700]

=== 8. IstioによるA/Bテスト

jason_というテストユーザのために、 `productpage` のトラフィックを _reviews:v2_ (黒い星) に、その他のトラフィックを _reviews:v3_ (赤い星) にルーティングして、評価サービスを有効にしてみましょう。以下を実行します:

[source, shell, role="copypaste"]
----
oc apply -n {{ USER_ID}}-bookinfo -f $CHE_PROJECTS_ROOT/cloud-native-workshop-v2m3-labs/istio/virtual-service-reviews-jason-v2-v3.yaml
----

[TIP]
====
次のような警告は無視してかまいません "_Warning: oc apply should be used on resource created by either oc create –save-config or oc apply_"
====

ルールが作成されたことを確認します:

[source, shell, role="copypaste"]
----
oc get virtualservices/reviews -n {{ USER_ID}}-bookinfo -o yaml
----

_match_ 要素に注目してください:

[source,yaml]
----
http:
  - match:
    - headers:
        end-user:
          exact: jason
    route:
    - destination:
        host: reviews
        subset: v2
  - route:
    - destination:
        host: reviews
        subset: v3
----

これは、 _jason_ ユーザーがセットされたクッキーを含むすべての着信 HTTP リクエストトラフィックを *reviews:v2* に、その他のトラフィックを *reviews:v3* に送信せよと言っています。

さて、http://istio-ingressgateway-{{USER_ID }}-istio-system.{{ ROUTE_SUBDOMAIN}}/productpage[Bookinfo Product Page^] にアクセスし、 *Sign In* (右上)をクリックしてサインインします:

* Username: *jason*
* Password: *jason*

[NOTE]
====
証明書のセキュリティ上の例外が発生した場合は、それを受け入れて続行するだけです。これは、自己署名証明書を使用しているためです。
====

ログインしたら、ブラウザを何度かリフレッシュしてください - あなたは `jason` としてログインしているので、常に *ratings:v2* から黒いレーティングスターが表示されているはずです。

image::ratings-testuser.png[Ratings for Test User, 700]

*サインアウト* すると、赤い評価の星が表示される *reviews:v3* 版に戻ります。

image::ratings-signout.png[Ratings for Test User, 700]

*おめでとうございます!* このラボでは、Istioを使用して、アプリケーションのサービスの特定のバージョンに100%のトラフィックを送信しました。次に
ルールを使用して、リクエスト中の条件 (例: ヘッダやユーザクッキー) にマッチするものに基づいて、他のバージョンのトラフィックを選択的に送信しました。

This routing allows you to selectively send traffic to different service instances, e.g. for testing, or blue/green deployments, or dark launches, and more.
このルーティング機能により、テスト、ブルー/グリーンデプロイメント、ダークローンチなどにおいて、異なるサービスインスタンスにトラフィックを選択的に送信することができます。

これを次のステップで探っていきます。
